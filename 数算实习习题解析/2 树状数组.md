# 树状数组 -- 模板

**树状数组用于解决单个元素经常修改，而且还反复求不同的区间和的情况。**

## 1. 公式

$$
C[i] = a[i - lowbit(i) + 1] + ...+a[i]\\
sum(i) = a[1] + ... + a[i] \\
sum(i) = C[n1] + ... + c[n_m] (n_m = k)\\
n_{m-1} = k - lowbit(k)\\
sum(k-lowbit(k)) = C[n_1] + ... + C[n_{m-1}]\\
$$

$lowbit(x) = x \& (x  \^ (x-1)) = x \& (-x)$



## 2. 时间代价

- 用$O(logN)$的时间求a数组任意区间的和$a[i] + a[i+1]+...+a[j]$
- 代价：更新一个元素$a[i]$所花的时间也是$O(logN)$，因为更新$a[i]$会导致C数组一些元素更新。
- 初始建组：时间复杂度是$O(N)$。

### 树状数组性能证明：求和。

$sum(k)$项数m决定了求区间和的时间复杂度。

$sum(k) = C[n_1] + C[n_2] + ... + C[n_m]$，其中  $n_m = k, n_{i-1} = n_i - lowbit(n_i)$

$sum(k)$里最多有$log_2k（向上取整）$项。

$C[i] = a[i - lowbit(i) + 1] + ... + a[i]$

### 树状数组性能证明：更新

#### 更新单个a元素

更新一个元素，C也要跟着更新，复杂度取决于C里有几项包含被更新的a元素。

$C[n_1], C[n_2], ... , C[n_m]$

其中$n_1 = i, n_{p+1} = n_p + lowvit(n_p)$

$n_m + lowbit(n_m)$必须大于a的元素个数N，$n_m$小于等于N。

同理说，总的来说更新一个元素的时间，也是$O(logN)$的。

### 构建树状数组：

初始状态下由a构建树状数组C的时间复杂度是$O(N)$

$C[k] = sum(k) - sum(k-lowbit(k))$

所有sum(k)可以在O(N)求出。

